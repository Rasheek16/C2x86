# Fixed Code

from _ast5 import *
from tacky_emiter import make_temporary, convert_binop, convert_unop
from typing import List, Dict, Any
import copy

temp_loop_label=0
def get_label():
    global temp_loop_label
    temp_loop_label+=1
    return f'loop.{temp_loop_label}'

def resolve_declaration(declaration, identifier_map: dict) :
    # print('Inside var decl'
    # declaration=declaration.declaration
    print(type(declaration))
    if isinstance(declaration,VarDecl):
        if not isinstance(declaration.name, Identifier):
            raise TypeError(f"Declaration name must be an Identifier, got {type(declaration.name)}")

        original_name = declaration.name.name
        # Check for duplicate declarations in the same block
        if original_name in identifier_map and identifier_map[original_name]['from_current_scope']:
            raise ValueError(f"Duplicate variable declaration: '{original_name}'")

        # Generate a unique name for the variable
        unique_name = make_temporary()

        # Update the variable map with the new unique name and metadata
        identifier_map[original_name] = {'unique_name': unique_name, 'from_current_scope': True,'has_linkage':False}

        # Resolve the initialization expression if present
        init = None  # Initialize to None
        if declaration.init is not None:
            init = resolve_exp(declaration.init, identifier_map)
        # Return the new declaration with the unique name and resolved initialization
        return VarDecl(name=Identifier(unique_name), init=init)
    elif isinstance(declaration,FunDecl):
        # print('Inside func decl')
        if isinstance(declaration.body,Null):
            raise SyntaxError('Body null')
        else:
            return resolve_function_declaration(declaration,identifier_map)
        
def resolve_exp(expression: Exp, identifier_map: dict) -> Exp:
    # print(type(expression))
    if isinstance(expression, Assignment):
        if not isinstance(expression.left, Var):
            raise ValueError(f"Invalid lvalue in assignment: {expression.left}")
        resolved_left = resolve_exp(expression.left, identifier_map)
        resolved_right = resolve_exp(expression.right, identifier_map)
        return Assignment(left=resolved_left, right=resolved_right)
    elif isinstance(expression, Conditional):
        # --- NEW CHECK HERE ---
        # If your grammar doesn't allow assignment expressions inside the ternary branches,
        # raise an error if either branch is an Assignment node.
        # if isinstance(expression.exp2, Assignment) or isinstance(expression.exp3, Assignment):
            # Or you can do deeper checks if the assignment is nested inside something else
            # raise ValueError("Invalid assignment in ternary expression according to the grammar.")
        resolved_condition = resolve_exp(expression.condition, identifier_map)
        resolved_exp2 = resolve_exp(expression.exp2, identifier_map)
        resolved_exp3 = resolve_exp(expression.exp3, identifier_map)
        return Conditional(condition=resolved_condition, exp2=resolved_exp2, exp3=resolved_exp3)
    elif isinstance(expression, Var):
        if not isinstance(expression.identifier, Identifier):
            raise TypeError(f"Expected Identifier, got {type(expression.identifier)}")
        # print(expression)
        original_identifier = expression.identifier.name

        if original_identifier in identifier_map.keys():
            unique_name = identifier_map[original_identifier]['unique_name']
            
            return Var(identifier=Identifier(unique_name))
        else:
            raise ValueError(f"Undeclared variable usage: '{original_identifier}'")
    elif isinstance(expression, Unary):
        resolved_expr = resolve_exp(expression.expr, identifier_map)
        return Unary(operator=expression.operator, expr=resolved_expr)
    elif isinstance(expression, Binary):
        resolved_left = resolve_exp(expression.left, identifier_map)
        resolved_right = resolve_exp(expression.right, identifier_map)
        return Binary(operator=expression.operator, left=resolved_left, right=resolved_right)
    elif isinstance(expression,FunctionCall):
        # new_identifier_map = create_identifier_map(identifier_map)
        # print(expression)
        if expression.identifier.name in identifier_map:
        # print(expression)
            new_func_name = identifier_map[expression.identifier.name]['unique_name']
            new_args = []
            # print('here in funccall')
            for arg in expression.args:
                # print(arg)
                new_args.append(resolve_exp(arg,identifier_map))    
            x=FunctionCall(Identifier(new_func_name),new_args)
            # print('fc',x)
            return x
        else:
            raise SyntaxError('Function is not declared')
    elif isinstance(expression, (Constant, Null)):
        return expression

    else:
        raise SyntaxError(f"Unknown expression type: {type(expression)}")


# def resolve_block_items(block_items: List[BlockItem], identifier_map: dict) -> List[BlockItem]:
#     """
#     Resolves a list of block items (declarations and statements) within a block.

#     Args:
#         block_items (List[BlockItem]): The list of block items to resolve.
#         identifier_map (dict): The current variable mapping.

#     Returns:
#         List[BlockItem]: The list of resolved block items.

#     Raises:
#         SyntaxError: If an unknown block item type is encountered.
#     """
#     # print('here')
#     resolved_body = []
#     for block_item in block_items:
#         # print(block_item)
#         if isinstance(block_item, D):
#             if isinstance(block_item.declaration,VarDecl):
#                 print('here')
#                 resolved_declaration = resolve_declaration(block_item, identifier_map)
#             elif isinstance(block_item.declaration,FunDecl):
#                 resolved_declaration = resolve_declaration(block_item, identifier_map)

#             resolved_body.append(D(declaration=resolved_declaration))
#         elif isinstance(block_item, S):
#             # print('S')
#             resolved_statement = resolve_statement(block_item.statement, identifier_map)
#             # print('S end')
#             # print(resolved_statement)
#             resolved_body.append(S(statement=resolved_statement))
#         elif isinstance(block_item, Compound):
#             # Handle nested blocks by creating a new scope
#             new_identifier_map = copy_identifier_map(identifier_map)
#             resolved_compound = Compound(block=resolve_block_items(block_items=block_item.block, identifier_map=new_identifier_map))
#             resolved_body.append(resolved_compound)
#         else:
#             raise SyntaxError(f"Unknown block item type: {type(block_item)}")
#     return resolved_body

def resolve_block_items(block_items: List[BlockItem], identifier_map: dict) -> List[BlockItem]:
    resolved_body = []
    for block_item in block_items:
        if isinstance(block_item, D):
            if isinstance(block_item.declaration, VarDecl):
                print('here')
                resolved_declaration = resolve_declaration(block_item.declaration, identifier_map)
            elif isinstance(block_item.declaration, FunDecl):
                resolved_declaration = resolve_declaration(block_item.declaration, identifier_map)
            resolved_body.append(D(declaration=resolved_declaration))
        elif isinstance(block_item, S):
            resolved_statement = resolve_statement(block_item.statement, identifier_map)
            resolved_body.append(S(statement=resolved_statement))
        elif isinstance(block_item, Compound):
            new_identifier_map = copy_identifier_map(identifier_map)
            resolved_compound = Compound(block=resolve_block_items(block_items=block_item.block, identifier_map=new_identifier_map))
            resolved_body.append(resolved_compound)
        else:
            raise SyntaxError(f"Unknown block item type: {type(block_item)}")
    return resolved_body

def copy_identifier_map(identifier_map: Dict[str, Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:
    """
    Creates a copy of the variable map with 'from_current_scope' set to False for every entry.

    Args:
        identifier_map (Dict[str, Dict[str, Any]]): The original variable map.

    Returns:
        Dict[str, Dict[str, Any]]: A new variable map with updated 'from_current_scope' flags.
    """
    new_map = copy.deepcopy(identifier_map)
    for var_info in new_map.values():
        var_info['from_current_scope'] = False
    return new_map

def create_identifier_map(identifier_map: Dict[str, Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:
    # Create a deep copy to avoid mutating the original identifier_map
    identifier_map = copy.deepcopy(identifier_map)
    
    old_key = 'from_current_scope'       # Corrected spelling
    new_key = 'from_current_scope'
    
    # Check if the old key exists in the identifier_map
    if old_key in identifier_map:
        # Assign the value to the new key
        identifier_map[new_key] = identifier_map.pop(old_key)
        print(f"Renamed '{old_key}' to '{new_key}'.")
    else:
        print(f"Key '{old_key}' does not exist in the identifier_map.")
    
    return identifier_map

def resolve_statement(statement, identifier_map: dict) -> Any:
    # print('stmt')
    # print(statement)
    """
    Resolves a single statement by mapping variable identifiers to their unique names.

    Args:
        statement: The statement to resolve.
        identifier_map (dict): The current variable mapping.

    Returns:
        The resolved statement.

    Raises:
        SyntaxError: If an invalid statement type is encountered.
    """
    if isinstance(statement, Return):
        # print(statement)
        resolved_exp = resolve_exp(statement.exp, identifier_map)
        # print(resolved_exp)
        return Return(exp=resolved_exp)
    elif isinstance(statement,For):
        new_identifier_map = copy_identifier_map(identifier_map)
        init = resolve_for_init(statement.init,new_identifier_map)
        condition = resolve_optional_exp(statement.condition,new_identifier_map)
        post = resolve_optional_exp(statement.post,new_identifier_map)
        body = resolve_statement(statement.body,new_identifier_map)
        labeled_statement=label_statement(For(init,condition,post,body))
        return For(init,condition,post,body)
    elif isinstance(statement, Expression):
        resolved_exp = resolve_exp(statement.exp, identifier_map)
        return Expression(exp=resolved_exp)
    elif isinstance(statement, Compound):
        # Handle nested blocks by creating a new scope
        new_identifier_map = copy_identifier_map(identifier_map)
        resolved_block = resolve_block_items(block_items=statement.block, identifier_map=new_identifier_map)
        return Compound(block=resolved_block)
    elif isinstance(statement,While):
        resolved_condition = resolve_exp(statement._condition,identifier_map)
        resolved_body = resolve_statement(statement.body,identifier_map)
        labeled_statement=label_statement(While(_condition=resolved_condition,body=resolved_body))
        return labeled_statement
    elif isinstance(statement,DoWhile):
        resolved_condition = resolve_exp(statement._condition,identifier_map)
        resolved_body = resolve_statement(statement.body,identifier_map)
        labeled_statement=label_statement(DoWhile(body=resolved_body,_condition=resolved_condition))
        return labeled_statement
    elif isinstance(statement,Break):
        return Break()
    elif isinstance(statement,Continue):
        return Continue()
    elif isinstance(statement, If):
        resolved_exp = resolve_exp(statement.exp, identifier_map)
        resolved_then = resolve_statement(statement.then, identifier_map)
        if statement._else is not None:
            resolved_else = resolve_statement(statement._else, identifier_map)
            return If(exp=resolved_exp, then=resolved_then, _else=resolved_else)
        else:
            return If(exp=resolved_exp, then=resolved_then)
    elif isinstance(statement, Null):
        return Null()
    else:
        raise SyntaxError(f"Invalid statement type: {type(statement)}")

def annotate(statement: Statement, label: int) -> Statement:
    """
    Annotates a given statement with the provided label.
    """
    statement.label = label
    return statement

def resolve_block(block_list,identifier_map):

       
    return (resolve_block_items(block_items=block_list,identifier_map=identifier_map))

def resolve_param(param:Parameter,identifier_map):
    print('resolve param')
    """
    Resolves a variable declaration by ensuring no duplicate declarations
    in the current block and mapping the variable to a unique name.

    Args:
        declaration (Declaration): The variable declaration with a name and optional initialization.
        identifier_map (dict): A mapping of variable names to their unique names and block metadata.

    Returns:
        Declaration: The resolved declaration with a unique name and resolved initialization.

    Raises:
        TypeError: If the declaration name is not an Identifier.
        ValueError: If the variable is already declared in the current block.
    """
    # print('inside resolve param',param.name)
    if not isinstance(param.name, Identifier):
        raise TypeError(f"Declaration name must be an Identifier, got {type(param.name)}")

    original_name = param.name.name
    # Check for duplicate declarations in the same block
    if original_name in identifier_map and identifier_map[original_name]['from_current_scope']:
        raise ValueError(f"Duplicate variable declaration: '{original_name}'")

    # Generate a unique name for the variable
    unique_name = make_temporary()

    # Update the variable map with the new unique name and metadata
    identifier_map[original_name] = {'unique_name': unique_name, 'from_current_scope': True,'has_linkage':False}
    # print('resolve param end')
    # Resolve the initialization expression if present
    return Parameter(name=Identifier(unique_name),_type=param._type)

def label_statement(statement: Statement, current_label: Optional[Identifier] = None) -> Statement:
    """
    Traverses and annotates the AST with loop labels.

    Args:
        statement (Statement): The AST node to process.
        current_label (Optional[Identifier]): The current loop label, if within a loop.

    Returns:
        Statement: The annotated AST node.
    """
    # Handle lists of statements
    if isinstance(statement, list):
        for stmt in statement:
            label_statement(stmt, current_label)
        return statement

    # Handle specific statement types
    if isinstance(statement, Break):
        if current_label is None:
            raise ValueError("Error: 'break' statement outside of loop")
        statement.label = current_label

    elif isinstance(statement, Continue):
        if current_label is None:
            raise ValueError("Error: 'continue' statement outside of loop")
        statement.label = current_label

    elif isinstance(statement, While):
        # Generate a new label for this While loop
        new_label = get_label()
        annotate(statement, new_label)
        label_statement(statement.body, new_label)

    elif isinstance(statement, For):
        # Generate a new label for this For loop
        new_label = get_label()
        annotate(statement, new_label)
        if statement.body:
            label_statement(statement.body, new_label)

    elif isinstance(statement, DoWhile):
        # Generate a new label for this DoWhile loop
        new_label = get_label()
        annotate(statement, new_label)
        label_statement(statement.body, new_label)

    elif isinstance(statement, Compound):
        # Traverse each block item within the compound statement
        for block_item in statement.block:
            label_statement(block_item, current_label)

    elif isinstance(statement, S):
        print(statement)
        # Traverse the wrapped statement
        label_statement(statement.statement, current_label)

    elif isinstance(statement, D):
        # Handle declarations and their initializations
        # print('error here')
        if statement.declaration.init:
            label_statement(statement.declaration.init, current_label)

    elif isinstance(statement, Conditional):
        # Traverse the conditional branches (exp2 and exp3)
        label_statement(statement.exp2, current_label)
        label_statement(statement.exp3, current_label)
    elif isinstance(statement,If):
        label_statement(statement._else,current_label)
        label_statement(statement.then,current_label)
    elif isinstance(statement, (Return,Var,Constant)):
        # No labeling needed for return statements
        pass

    elif isinstance(statement, (Expression,Assignment,Binary,Unary)):
        # No labeling needed for expressions
        pass
    
    elif isinstance(statement, Null):
        # No labeling needed for null statements
        pass

    else:
        # Handle other statement types or raise an error
        raise TypeError(f"Unsupported statement type: {type(statement)}")

    return statement

def resolve_for_init(stmt,identifier_map):
    if isinstance(stmt,InitDecl):
        print(type(stmt.declaration))
        return InitDecl(D(resolve_declaration(stmt.declaration,identifier_map)))
    elif isinstance(stmt,InitExp):
        return InitExp(Expression(resolve_statement(stmt.exp,identifier_map)))
    elif isinstance(stmt,Null):
        return stmt
    else:
        raise TypeError('invalid init condition',stmt)
    
def resolve_optional_exp(stmt,identifier_map):
    if stmt is not None:
        return resolve_exp(stmt,identifier_map)
    else:
        print('No statment')
        pass 
        
def label_program(program: Program):
    """
    Labels all loops in the program's AST.
    
    Args:
        program (Program): The AST of the entire program.
    
    Returns:
        Program: The labeled AST.
    """
    # print('here')
    label_statement(program.function_definition.body, None)
    return program    

# def resolve_function(function: Function, identifier_map: dict) -> Function:
#     """
#     Resolves all block items within a function.

#     Args:
#         function (Function): The function to resolve.
#         identifier_map (dict): The current variable mapping.

#     Returns:
#         Function: The resolved function with all variables uniquely named.
#     """
#     resolved_body = resolve_block_items(block_items=function.body, identifier_map=identifier_map)
#     return Function(name=function.name, body=resolved_body)




def resolve_function_declaration(decl:FunDecl,identifier_map):
    # print(decl.name.name)
    # print('resolve func decl')
    # print('Error not here')
    if decl.name.name in identifier_map:
        prev_entry = identifier_map[decl.name.name]
        if prev_entry['from_current_scope'] and not prev_entry['has_linkage']==True:
            raise SyntaxError('Duplicate declaration')
    identifier_map[decl.name.name]={'unique_name':decl.name.name,'from_current_scope':True,'has_linkage':True}
    # print('error not here')
    inner_map = copy_identifier_map(identifier_map)
    # print('heredfadas')
    # print(inner_map)
    new_param =[]
    # print(decl.params)
    for param in decl.params:
        # print(param)
        new_param.append(resolve_param(param,inner_map))
        # print('here')
    # print(decl.body)
    new_body = Null
    if  isinstance(decl.body,Block):
        # print(decl.body.block_items)
        # print('here')
        new_body=resolve_block(decl.body.block_items,inner_map)
        # print('here after')
        # print(new_body)
    return FunDecl(decl.name,new_param,new_body)
def variable_resolution_pass(program: Program) -> Program:
    """
    Performs the variable resolution pass on the entire program.

    Args:
        program (Program): The program to resolve.

    Returns:
        Program: The resolved program with all variables uniquely named.
    """
    identifier_map = {}
    func=[]
    for x in program.function_definition:
        # print(x)
        new_func=resolve_function_declaration(x,identifier_map)
        # print(new_func)
        func.append(new_func)
        
    # resolved_function = resolve_function(program.function_definition, identifier_map)
    # print('here')
    prog=Program(function_definition=func)
    return prog







# pseudoregister_replacer.py

from typing import Dict, Tuple, List
from assembly_ast import *
import sys
from instruction_fixer import round_up_to_multiple_of_16



def replace_pseudoregisters(assembly_program: AssemblyProgram) -> Tuple[AssemblyProgram, Dict[str, int]]:
    """
    Replaces all Pseudo operands in the Assembly AST with Stack operands for each function.
    Calculates and returns the stack allocation required for each function.

    Additionally, rewrites 'idiv', 'add', 'sub', and 'imul' instructions to adhere to assembly constraints
    (especially for 64-bit mode).

    NOTE: This version uses 8-byte slots for each pseudo register and inserts 'Cdq' before 'idiv'.
    """
    stack_allocations: Dict[str, int] = {}

    # Assume a single function for simplicity
    for assembly_func in assembly_program.function_definition:
        # print(assembly_func)

        # Maps pseudo register names to stack offsets
        pseudo_map: Dict[str, int] = {}

        # Initialize stack offset; start at -8(%rbp)
        # current_offset
        # List to hold the new set of instructions after replacement
        current_offset= -8
        
        new_instructions: List[Instruction] = []
        def replace_pseudo_with_stack(operand):
            """
            If the operand is a Pseudo, replace it with a Stack operand at the next available offset.
            """
            nonlocal current_offset
            
            if isinstance(operand, Pseudo):
                name = operand.identifier
                if name not in pseudo_map:
                    pseudo_map[name] = current_offset
                    current_offset -= 8  # Allocate 8 bytes for each pseudo register
                return Stack(pseudo_map[name])
            return operand
        params=assembly_func.instructions[0]
        new_params=[]
        # print('parameters',params)
        for param in params:
            if isinstance(param, Mov):  # Assuming parameters are identified by their names as strings
                param.dest=replace_pseudo_with_stack(param.dest)
                param.src=replace_pseudo_with_stack(param.src) 
                new_params.append(param)
            #     param=param.dest
            #     pseudo_map[param] = current_offset
            #     current_offset -= 8  # Allocate 8 bytes for each parameter
            # else:
            #     print(f"Unexpected parameter type: {type(param).__name__} in function '{assembly_func.name}'.", file=sys.stderr)
            #     sys.exit(1)
        # Iterate through each instruction in the function
        # new_instructions.extend(new_params)
        # print('new_params',new_params)
        new_instructions.extend(new_params)
        instrs=assembly_func.instructions[1:]
        for instr in instrs :

            if isinstance(instr, Mov):
                # Replace source and destination if they are Pseudo
                instr.src = replace_pseudo_with_stack(instr.src)
                instr.dest = replace_pseudo_with_stack(instr.dest)
                new_instructions.append(instr)
            
            elif isinstance(instr, Unary):
                # Replace the operand if it's a Pseudo
                instr.operand = replace_pseudo_with_stack(instr.operand)
                new_instructions.append(instr)
            
            elif isinstance(instr, Binary):
                # Replace src1 and src2 if they are Pseudo
                instr.src1 = replace_pseudo_with_stack(instr.src1)
                instr.src2 = replace_pseudo_with_stack(instr.src2)
                new_instructions.append(instr)
            
            elif isinstance(instr, Idiv):
                # Replace the operand if it's a Pseudo
                instr.operand = replace_pseudo_with_stack(instr.operand)
                new_instructions.append(instr)
            
            elif isinstance(instr, Cmp):
                # Replace the operand if it's a Pseudo
                instr.operand1 = replace_pseudo_with_stack(instr.operand1)
                instr.operand2 = replace_pseudo_with_stack(instr.operand2)
                new_instructions.append(instr)
            elif isinstance(instr, SetCC):
                # Replace the operand if it's a Pseudo
                # print('STECC',instr)
                instr.operand = replace_pseudo_with_stack(instr.operand)
                new_instructions.append(instr)
                # instr.operand2 = replace_pseudo_with_stack(instr.operand2)
            elif isinstance(instr,Push):
                instr.operand=replace_pseudo_with_stack(instr.operand)
                new_instructions.append(instr)
            elif isinstance(instr, (AllocateStack, Ret, Cdq,JmpCC,Jmp,Label,Call,DeallocateStack)):
                # These instructions do not contain Pseudo operands; add them directly
                new_instructions.append(instr)
            
            else:
                # Unsupported instruction type encountered
                print(f"Unsupported instruction type: {type(instr).__name__} in function '{assembly_func.name}'.", file=sys.stderr)
                sys.exit(1)

        # Update the function's instructions with the new set of instructions
        # assembly_func.instructions=new_params
        assembly_func.instructions=new_instructions
        
        # Calculate total stack allocation required for all replaced pseudoregisters
        # Since current_offset started at -8 and decremented by 8 for each Pseudo
        # The total allocation is the absolute value of (current_offset + 8)
        # total_stack_allocation = abs(current_offset + 8)
        total_stack_allocation = abs(current_offset + 8)
        total_stack_allocation = round_up_to_multiple_of_16(total_stack_allocation)

        stack_allocations[assembly_func.name] = total_stack_allocation

    return assembly_program, stack_allocations




















    
from _ast5 import *
from typing import Optional, List
from type_classes import *
import sys


def get_common_type(type1,type2):
    print(type1)
    if type(type1)==type(type2):
        return type1
    else:
        return Long()
    
def convert_to(e:Exp,t:any):
    print('converting',e)
    if e.get_type() == t:
        return e 
    cast_exp=Cast(target_type=t,exp=e)
    cast_exp.set_type(t)
    return cast_exp
        

def typecheck_file_scope_variable_declaration(decl: VarDecl, symbols: dict):
    print('Inside file scope vardecl',decl,'\n')
    """
    Type checks a file-scope variable declaration and updates the symbol table accordingly.
    Ensures linkage consistency and proper initialization handling.
    """
    # Step 1: Derive the "new_init" based on the decl.init:
    if isinstance(decl.init, Constant) and isinstance(decl.init.value,(ConstInt,ConstLong)):
        if (decl.init.get_type(),Long): 
            new_init = Initial(StaticInit.LongInit(decl.init.value))
        else:
            new_init=Initial(StaticInit.InitInit(decl.init.value))
            
        # e.    g. "static int foo = 4;" => real definition
    elif isinstance(decl.init, Null):
        # e.g. "static int foo;" => tentative
        # e.g. "extern int foo;" => no initializer
        if isinstance(decl.storage_class, Extern):
            new_init = NoInitializer()
        else:
            new_init = Tentative()
    else:
        # print('here')
        
        # Non-constant initializer is not allowed at file scope per your spec
        raise SyntaxError("Non-constant initializer!", decl.storage_class)

    # Step 2: Determine linkage based on storage class
    # static => internal linkage => global_scope=False
    # otherwise => external linkage => global_scope=True
    global_scope = not isinstance(decl.storage_class, Static)
    # Step 3: Check if the name already exists in the symbol table
    var_name = decl.name.name
    if var_name in symbols:
        # We already have a declaration for this nameres
        old_decl = symbols[var_name]

        # Must be the same type
        if not isinstance(old_decl['type'], Int):
            raise TypeError("Function redeclared as variable")

        # Merge linkage
        old_global_scope = old_decl['attrs'].global_scope
        if isinstance(decl.storage_class, Extern):
            # 'extern' after a static => keep the old linkage (internal if it was static)
            final_linkage = old_global_scope
        else:
            # If new is static but old was external (or vice versa), conflict
            if old_global_scope != global_scope:
                raise ValueError("Conflicting variable linkage")
            final_linkage = old_global_scope

        # Now do the initializer merge:
        old_init = old_decl['attrs'].init  # could be Initial(...), Tentative(), NoInitializer()
        new_init = new_init               # from above

        # Helper checks:
        def is_initial(i): return isinstance(i, Initial)
        def is_tentative(i): return isinstance(i, Tentative)
        def is_noinit(i): return isinstance(i, NoInitializer)

        if is_initial(old_init):
            # Old was already a real definition
            if is_initial(new_init):
                # Another real definition => conflict
                raise ValueError("Conflicting file-scope variable definitions")
            else:
                # Keep the old real definition
                final_init = old_init

        elif is_tentative(old_init):
            # Old was 'static int x;' with no init
            if is_initial(new_init):
                # Upgrading from tentative to real
                final_init = new_init
            else:
                # Another 'static int x;' or 'extern int x;' => keep the old tentative
                final_init = old_init

        elif is_noinit(old_init):
            # Old was 'extern int x;'
            if is_initial(new_init) or is_tentative(new_init):
                # Now we have a real or tentative => adopt new
                final_init = new_init
            else:
                # Another extern => no change
                final_init = old_init
        else:
            raise RuntimeError("Unknown initializer type in old declaration")

    else:
        # There's no old symbol => we take the new
        final_linkage = global_scope
        final_init = new_init

    # Step 4: Construct the new attributes
    attrs = StaticAttr(init=final_init, global_scope=final_linkage)

    # Step 5: Update the symbol table
    symbols[var_name] = {
        'type': Int(),
        'attrs': attrs
    }

        # print(symbols)
         
def typecheck_local_vairable_declaration(decl:VarDecl,symbols:dict):
    print('typechecking local var dec',decl,'\n')
    try:
        if isinstance(decl.storage_class,Extern):
            if not isinstance(decl.init ,Null):
                raise SyntaxError('Initializer on local extern variable declaration')
            
            if decl.name.name in symbols:
                old_decl =  symbols[decl.name.name]
                if not isinstance(old_decl['type'],Int):
                    raise SyntaxError('Function redeclared as variable')
            else:
                # print(initial_value)
                symbols[decl.name.name]={
                    'type':Int(),
                    'attrs':StaticAttr(init=NoInitializer(),global_scope=True)
                }
        elif isinstance(decl.storage_class,Static):
            if isinstance(decl.init,Constant):
                initial_value =Initial(decl.init)
                # print(initial_value)
            elif isinstance(decl.init,Null):
                initial_value = Initial(Constant(0))
                # initial_value = NoInitializer()
            else:
                raise SyntaxError('Non-constant Initializer on local static variable',decl.init)
            # print(initial_value)
           
            symbols[decl.name.name]={
                'type':Int(),
                'attrs':StaticAttr(init=initial_value,global_scope=False)
            }
        else:
            symbols[decl.name.name]={
                'type':Int(),
                'attrs':LocalAttr()
            }
            if not isinstance(decl.init,Null):
                typecheck_exp(decl.init,symbols)
    except Exception as e:
        raise e
        
def typecheck_function_declaration(decl: FunDecl, symbols: dict,is_block_scope):
    print('Type checking function decl',decl,'\n')
    
    """
    Type checks a function declaration by adding it to the symbol table,
    ensuring no conflicting declarations, and type checking the function body.
    """
    fun_name = decl.name.name
    fun_type = FunType(param_count=len(decl.params),params=decl.params,ret=decl.fun_type)
    has_body = decl.body is not None and not isinstance(decl.body, Null)
    already_defined = False
    _global = decl.storage_class
    if not isinstance(_global,Static):
        _global=True 
    else:
        _global=False
  
    
    if fun_name in symbols:
        print('new func')
        
        old_decl = symbols[fun_name]
        # return
        # print(f"Function '{fun_name}' already in symbol table: {old_decl}")

        # Ensure the existing declaration is a function
        if 'fun_type' not in old_decl:
            raise SyntaxError(f"Identifier '{fun_name}' previously declared as a variable.")
        already_defined = old_decl['attrs'].defined

        # Compare the number of parameters
        if old_decl['fun_type'].param_count != fun_type.param_count:
            raise SyntaxError(
                f"Incompatible function declarations for '{fun_name}'. "
                f"Expected {old_decl['fun_type'].param_count} parameters, "
                f"got {fun_type.param_count}."
            )
        if already_defined and has_body:
            raise SyntaxError("Function is defined more than once")
 
 
        if old_decl['attrs'].global_scope and isinstance(decl.storage_class,Static):
            raise SyntaxError('Static funtion declarartion follow a non static ')
        
        if is_block_scope:
            if _global and isinstance(decl.storage_class,Static):
                raise SyntaxError('a block-scope function may only have extern storage class')
            
        _global = old_decl['attrs'].global_scope
        # print(_global)
        attrs = FunAttr(defined=(already_defined or has_body), global_scope=_global)
        # print(attrs)
        symbols[fun_name]={
            'fun_type':FunType(param_count=len(decl.params),params=decl.params,ret=decl.fun_type),
            'attrs':attrs
        }
        
        # print(decl)
        # return
        print(has_body)
        if has_body:
            for stmt in decl.body:
                # print('checkingstatem')
                for param in decl.params:
                    param_name = param.name.name
                    if param_name in symbols:
                        raise SyntaxError(f"Parameter '{param_name}' is already declared.")
                    symbols[param_name] = {'type': Int(),'attrs':None}
                if not isinstance(stmt,Return):
                    print('type checking function body',stmt)
                    # print(symbols)
                    # sys.exit(0)
                    # print('converting statment return')
                    typecheck_statement(decl.body, symbols)
                else:
                    if stmt.exp is not None and not isinstance(stmt.exp, Null):
                        typed_return=typecheck_exp(stmt.exp, symbols)
                        convert_to(typed_return,decl.fun_type)
            # symbols[fun_name]['defined'] = True
            #print(f"Defining function '{fun_name}'.")

            # Add each parameter to the symbol table with type Int
                #print(f"Declared parameter '{param_name}' with type Int.")
            
                
       
        # print('check body')
        # print(decl.body)
        # if isinstance(decl.body,Null):
        # print(decl.body)
            
            
            
                        # Type check the function body
    else:
        print('old func')
        
        # print(is_block_scope)
        if is_block_scope:
            if not _global and isinstance(decl.storage_class,Static):
               
                raise SyntaxError('a block-scope function may only have extern storage class')
        
        # Add a new function declaration or definition
        symbols[fun_name] = {'fun_type': FunType(param_count=len(decl.params),params=decl.params,ret=decl.fun_type),'attrs':FunAttr(defined=has_body,global_scope=_global)}
        #print(f"Declared function '{fun_name}' with type FunType(param_count={fun_type.param_count}).")

        if has_body:
            #print(f"Defining function '{fun_name}'.")

            # Add each parameter to the symbol table with type Int
            for param in decl.params:
                param_name = param.name.name
                if param_name in symbols:
                    raise SyntaxError(f"Parameter '{param_name}' is already declared.")
                symbols[param_name] = {'type': Int(),'attrs':None}
                #print(f"Declared parameter '{param_name}' with type Int.")
            # Type check the function body
            typecheck_statement(decl.body, symbols)

    #print(f"Symbol table after processing function '{fun_name}': {symbols}")


def typecheck_exp(e: Expression, symbols: dict):
    print('Type checking expressions',e)
    
    
    
    """
    Type checks an expression by ensuring correct usage of variables and functions.
    """
    
    if isinstance(e, FunctionCall):
        fun_name = e.identifier.name
        
        if fun_name not in symbols:
            raise NameError(f"Function '{fun_name}' is not defined.")
        
        fun_entry = symbols[fun_name]
   
        
        # Ensure that the identifier is a function
        if  not isinstance(fun_entry['fun_type'],FunType):
            raise SyntaxError(f"Variable '{fun_name}' used as a function.")
        
        if isinstance(fun_entry['fun_type'],FunType):
            f_type:FunType = fun_entry['fun_type']
            
            # Check if the number of arguments matches the function's parameter count
            if f_type.param_count != len(e.args):
                raise SyntaxError(f"Function '{fun_name}' called with wrong number of arguments. Expected {f_type.param_count}, got {len(e.args)}.")
            
            converted_args=[]
            params=[val._type for val in  f_type.params]
            # params_types = [types]
            for (arg,paramType) in zip(e.args,params):
                typed_Arg = typecheck_exp(arg,symbols)
                converted_args.append(convert_to(typed_Arg,paramType))
                
            call_exp = FunctionCall(e.identifier,converted_args)
            call_exp.set_type(f_type.ret)
                
            #print(f"Calling function '{fun_name}' with {len(e.args)} arguments.")
            
            # Recursively type check each argument
            
            for arg in e.args:
                typecheck_exp(arg, symbols)
            return call_exp
    
    elif isinstance(e, Var):
        print('Typingchecking_var',e)
        var_name = e.identifier.name
     
        if var_name not in symbols:
            raise NameError(f"Variable '{var_name}' is not defined.")
        
        var_entry = symbols[var_name]
        
        # Ensure that the identifier is a variable, not a function
        if 'type' not in var_entry:
            raise SyntaxError(f"Function '{var_name}' used as a variable.")
        var_type = var_entry['type']
        if not isinstance(var_type, Int):
            raise SyntaxError(f"Identifier '{var_name}' does not have type Int.")
        
        e.set_type(var_type)
        # print('finalvar')
        return e
    
    elif isinstance(e, Return):
        # print('asdsadasd')
        # Type check the return expression if present
        if e.exp is not None and not isinstance(e.exp, Null):
            return typecheck_exp(e.exp, symbols)
    
    elif isinstance(e, Constant):
        print(e.value)
        if isinstance(e.value,ConstInt):
            # e.value.set_type(Int())
            return ConstInt(int=e.value,_type = Int())
        elif isinstance(e.value,ConstLong):
            # e.value.set_type(Long())
            return ConstInt(int=e.value,_type = Long())
        else:
            raise SyntaxError('Invalid value const')

    elif isinstance(e,Cast):
        typed_inner = typecheck_exp(e.exp,symbols)
        cast_exp = Cast(target_type=e._type,exp=typed_inner)
        cast_exp.set_type(e._type)
        return cast_exp
    elif isinstance(e, (Assignment, Binary, Unary)):
        # Type check sub-expressions
        if isinstance(e, Assignment):
            print('type checking assignment',e)
            type_left=typecheck_exp(e.left, symbols)
            type_right=typecheck_exp(e.right, symbols)
            left_type=type_left.get_type()
            converted_right = convert_to(type_right,left_type)
            assign_exp=Assignment(type_left,converted_right)
            assign_exp.set_type(left_type)
            return assign_exp
            #print(f"Assignment operation between '{e.left}' and '{e.right}'.")
        elif isinstance(e, Binary):
            print('Type checking binary Statemnt',e,'\n')
            
            typed_e1=typecheck_exp(e.left, symbols)
   
            typed_e2=typecheck_exp(e.right, symbols)
            
            if e.operator in (BinaryOperator.AND,BinaryOperator.OR):
                binary_exp = Binary(operator=e.operator,left=typed_e1,right=typed_e2)
                binary_exp.set_type(Int)
                return binary_exp
         
            
            t1=typed_e1.get_type()
            t2=typed_e2.get_type()
            # print('t1',t1)
            # print('t2',t2)
            
            common_type=get_common_type(t1,t2)
            # print('common_type',common_type)
            converted_e1=convert_to(e=typed_e1,t=common_type)
            # print(converted_e1)
            converted_e2=convert_to(e=typed_e1,t=common_type)
            # print(converted_e2)
            print('Converted binary left',converted_e1)
            print('Converted binary right',converted_e2)
            
            binary_exp=Binary(operator=e.operator,left=converted_e1,right=converted_e2)
            print(binary_exp)
            if e.operator in (BinaryOperator.ADD,BinaryOperator.DIVIDE,BinaryOperator.MULTIPLY,BinaryOperator.SUBTRACT,BinaryOperator.REMAINDER):
                
                # binary_exp.set_type(common_type)
                return Binary(operator=e.operator,left=converted_e1,right=converted_e2,_type =common_type)
                
            else:
                # binary_exp.set_type(Int)
                return Binary(operator=e.operator,left=converted_e1,right=converted_e2,_type =Int())
            
            
            
            #print(f"Binary operation between '{e.left}' and '{e.right}'.")
        elif isinstance(e, Unary):
            inner=typecheck_exp(e.expr, symbols)
            unary_exp = Unary(operator=e.operator,expr=inner)
            if e.operator ==UnaryOperator.NOT:
                unary_exp.set_type(e._type)
                return unary_exp
            else:
                # print('here')
                unary_exp.set_type(inner.get_type())
                return unary_exp
            #print(f"Unary operation on '{e.expr}'.")
    elif isinstance(e,Null):      
        pass
    elif isinstance(e,Conditional):
        typecheck_statement(e,symbols)
    else:
        raise TypeError(f"Unsupported expression type for type checking: {type(e)}")

def typecheck_statement(statement: Statement, symbols: dict):
    print('Type checking statament',statement,'\n')
    """
    Recursively traverses the AST and performs type checking for variable and function declarations.
    For other statements, it traverses their child statements or expressions.
    """
    #print(statement)
    if isinstance(statement, list):
        for stmt in statement:
            typecheck_statement(stmt, symbols)
        return statement

    if isinstance(statement, VarDecl):
        # print(symbols)
        typecheck_local_vairable_declaration(statement, symbols)
    
    elif isinstance(statement,InitDecl):
        typecheck_statement(statement.declaration.declaration,symbols)
    
    elif isinstance(statement,InitExp):
        typecheck_statement(statement.exp,symbols)
    elif isinstance(statement, FunDecl):
        typecheck_function_declaration(statement, symbols,is_block_scope=True)
    
    elif isinstance(statement, (Break, Continue)):
        # Assuming labeling is handled elsewhere; no type checking needed
        pass
    
    elif isinstance(statement,Expression):
        typecheck_statement(statement.exp,symbols)
    
    elif isinstance(statement, (While, For, DoWhile)):
        # Type check the loop condition and traverse the loop body
        if isinstance(statement, While):
            typecheck_exp(statement._condition, symbols)
            typecheck_statement(statement.body, symbols)
            #print("Type checked a 'while' loop.")
        
        elif isinstance(statement, For):
            if isinstance(statement.init,InitDecl):
                if statement.init and not isinstance(statement.init,Null):
                    if isinstance(statement.init.declaration.declaration,VarDecl):
                        if isinstance(statement.init.declaration.declaration.storage_class,(Extern,Static)):
                            
                            print('here')
                            raise SyntaxError('Loop initializer cannot have storage class')
                        else: 
                            typecheck_statement(statement.init, symbols)
                        
            else:
                typecheck_statement(statement.init, symbols)
            if statement.condition:
                typecheck_exp(statement.condition, symbols)
            if statement.post:
                typecheck_exp(statement.post, symbols)
            #print(type(statement.body))
            typecheck_statement(statement.body, symbols)
            #print("Type checked a 'for' loop.")
        
        elif isinstance(statement, DoWhile):
            typecheck_statement(statement.body, symbols)
            typecheck_exp(statement._condition, symbols)
            #print("Type checked a 'do-while' loop.")
    
    elif isinstance(statement, Compound):
        # Traverse each statement in the compound block
        for stmt in statement.block:
            #print("Type checked a compound statement.")
            typecheck_statement(stmt, symbols)

    elif isinstance(statement, S):
        # Assuming S wraps another statement
        typecheck_statement(statement.statement, symbols)
    
    elif isinstance(statement, D):
        # Handle different types of declarations within D
        if isinstance(statement.declaration, FunDecl):
            print(statement.declaration)
            typecheck_function_declaration(statement.declaration, symbols,is_block_scope=True)
        elif isinstance(statement.declaration, VarDecl):
            typecheck_local_vairable_declaration(statement.declaration, symbols)
        else:
            raise TypeError(f"Unsupported declaration type in D: {type(statement.declaration)}")
    
    elif isinstance(statement, Conditional):
        
      
        
        # Type check expressions and traverse corresponding statements
        # print('dfasdasdas')
        if statement.condition:
            typed_condition=typecheck_statement(statement.condition, symbols)
            print(typed_condition)
        if statement.exp2:
            typed_exp2 = typecheck_statement(statement.exp2, symbols)
            print(typed_exp2)
            # print(statement.exp2)
            
        #     print('here')
            exp2_type=typed_exp2.get_type()
            print('typed_exp2',typed_exp2)
            
            
        if statement.exp3:
            print('dasdasada',statement.exp3)
            typed_exp3=typecheck_statement(statement.exp3, symbols)
            print(typed_exp3)
            exp3_type = typed_exp3.get_type()
            print('typed_exp3',typed_exp3)
            # sys.exit(0)
        #     # sys.exit(0)       
            
        common_type = get_common_type(exp2_type,exp3_type)
        typed_exp2.set_type(common_type)
        typed_exp3.set_type(common_type)
        
        return Conditional(condition=typed_condition,exp2=typed_exp2,exp3=typed_exp3)
     
            
        
        #print("Type checked a conditional statement.")
    
    elif isinstance(statement, If):
        # Type check the condition and traverse 'then' and 'else' branches
        typecheck_exp(statement.exp, symbols)
        typecheck_statement(statement.then, symbols)
        if statement._else:
            typecheck_statement(statement._else, symbols)
        #print("Type checked an 'if' statement.")
    
    elif isinstance(statement, FunctionCall):
        # Function calls as standalone statements
        typecheck_exp(statement, symbols)
    
    elif isinstance(statement, Return):
        # Type check return expressions
        if isinstance(statement,Statement):
            print(statement.exp)
            return typecheck_statement(statement.exp,symbols)
        else:
            return typecheck_exp(statement, symbols)
    
    elif isinstance(statement, (Expression, Assignment, Binary, Unary)):
        if isinstance(statement,Assignment):
            left=typecheck_statement(statement.left,symbols)
            right= typecheck_statement(statement.right,symbols)
            return Assignment(left,right)
        else:
            # Type check expressions
            print('Type checking binary')
            typecheck_exp(statement, symbols)
    
    elif isinstance(statement,Cast):
        return typecheck_exp(statement,symbols)
    elif isinstance(statement, Var):
        # Type check variable usage
        print('type checking var ',statement)
        return typecheck_exp(statement, symbols)
    
    elif isinstance(statement, Constant):
        # Type check constant usage
        return typecheck_exp(statement, symbols)
    
    elif isinstance(statement, Null):
        # No action needed for Null statements
        pass
    
    else:
        raise TypeError(f"Unsupported statement type for type checking: {type(statement)}")

def typecheck_program(program:Program):
    """
    Initiates the type checking process for the entire program.
    """
      # Single symbol table dictionary
    symbols = {}
    #print("Starting type checking of the program.")
    for stmt in program.function_definition:
        print(stmt)
        if isinstance(stmt,VarDecl):
            print('vardecl')
            typecheck_file_scope_variable_declaration(stmt,symbols)
        elif isinstance(stmt,FunDecl):
            print('funcdecl')
            typecheck_function_declaration(stmt, symbols,False)
        else:
            print('stmt')
            typecheck_statement(stmt,symbols)
    #print("Type checking completed successfully.")
    return program,symbols