# Fixed Code

from _ast5 import *
from tacky_emiter import make_temporary, convert_binop, convert_unop
from typing import List, Dict, Any
import copy

temp_loop_label=0
def get_label():
    global temp_loop_label
    temp_loop_label+=1
    return f'loop.{temp_loop_label}'

def resolve_declaration(declaration, identifier_map: dict) :
    # print('Inside var decl'
    # declaration=declaration.declaration
    print(type(declaration))
    if isinstance(declaration,VarDecl):
        if not isinstance(declaration.name, Identifier):
            raise TypeError(f"Declaration name must be an Identifier, got {type(declaration.name)}")

        original_name = declaration.name.name
        # Check for duplicate declarations in the same block
        if original_name in identifier_map and identifier_map[original_name]['from_current_scope']:
            raise ValueError(f"Duplicate variable declaration: '{original_name}'")

        # Generate a unique name for the variable
        unique_name = make_temporary()

        # Update the variable map with the new unique name and metadata
        identifier_map[original_name] = {'unique_name': unique_name, 'from_current_scope': True,'has_linkage':False}

        # Resolve the initialization expression if present
        init = None  # Initialize to None
        if declaration.init is not None:
            init = resolve_exp(declaration.init, identifier_map)
        # Return the new declaration with the unique name and resolved initialization
        return VarDecl(name=Identifier(unique_name), init=init)
    elif isinstance(declaration,FunDecl):
        # print('Inside func decl')
        if isinstance(declaration.body,Null):
            raise SyntaxError('Body null')
        else:
            return resolve_function_declaration(declaration,identifier_map)
        
def resolve_exp(expression: Exp, identifier_map: dict) -> Exp:
    # print(type(expression))
    if isinstance(expression, Assignment):
        if not isinstance(expression.left, Var):
            raise ValueError(f"Invalid lvalue in assignment: {expression.left}")
        resolved_left = resolve_exp(expression.left, identifier_map)
        resolved_right = resolve_exp(expression.right, identifier_map)
        return Assignment(left=resolved_left, right=resolved_right)
    elif isinstance(expression, Conditional):
        # --- NEW CHECK HERE ---
        # If your grammar doesn't allow assignment expressions inside the ternary branches,
        # raise an error if either branch is an Assignment node.
        # if isinstance(expression.exp2, Assignment) or isinstance(expression.exp3, Assignment):
            # Or you can do deeper checks if the assignment is nested inside something else
            # raise ValueError("Invalid assignment in ternary expression according to the grammar.")
        resolved_condition = resolve_exp(expression.condition, identifier_map)
        resolved_exp2 = resolve_exp(expression.exp2, identifier_map)
        resolved_exp3 = resolve_exp(expression.exp3, identifier_map)
        return Conditional(condition=resolved_condition, exp2=resolved_exp2, exp3=resolved_exp3)
    elif isinstance(expression, Var):
        if not isinstance(expression.identifier, Identifier):
            raise TypeError(f"Expected Identifier, got {type(expression.identifier)}")
        # print(expression)
        original_identifier = expression.identifier.name

        if original_identifier in identifier_map.keys():
            unique_name = identifier_map[original_identifier]['unique_name']
            
            return Var(identifier=Identifier(unique_name))
        else:
            raise ValueError(f"Undeclared variable usage: '{original_identifier}'")
    elif isinstance(expression, Unary):
        resolved_expr = resolve_exp(expression.expr, identifier_map)
        return Unary(operator=expression.operator, expr=resolved_expr)
    elif isinstance(expression, Binary):
        resolved_left = resolve_exp(expression.left, identifier_map)
        resolved_right = resolve_exp(expression.right, identifier_map)
        return Binary(operator=expression.operator, left=resolved_left, right=resolved_right)
    elif isinstance(expression,FunctionCall):
        # new_identifier_map = create_identifier_map(identifier_map)
        # print(expression)
        if expression.identifier.name in identifier_map:
        # print(expression)
            new_func_name = identifier_map[expression.identifier.name]['unique_name']
            new_args = []
            # print('here in funccall')
            for arg in expression.args:
                # print(arg)
                new_args.append(resolve_exp(arg,identifier_map))    
            x=FunctionCall(Identifier(new_func_name),new_args)
            # print('fc',x)
            return x
        else:
            raise SyntaxError('Function is not declared')
    elif isinstance(expression, (Constant, Null)):
        return expression

    else:
        raise SyntaxError(f"Unknown expression type: {type(expression)}")


# def resolve_block_items(block_items: List[BlockItem], identifier_map: dict) -> List[BlockItem]:
#     """
#     Resolves a list of block items (declarations and statements) within a block.

#     Args:
#         block_items (List[BlockItem]): The list of block items to resolve.
#         identifier_map (dict): The current variable mapping.

#     Returns:
#         List[BlockItem]: The list of resolved block items.

#     Raises:
#         SyntaxError: If an unknown block item type is encountered.
#     """
#     # print('here')
#     resolved_body = []
#     for block_item in block_items:
#         # print(block_item)
#         if isinstance(block_item, D):
#             if isinstance(block_item.declaration,VarDecl):
#                 print('here')
#                 resolved_declaration = resolve_declaration(block_item, identifier_map)
#             elif isinstance(block_item.declaration,FunDecl):
#                 resolved_declaration = resolve_declaration(block_item, identifier_map)

#             resolved_body.append(D(declaration=resolved_declaration))
#         elif isinstance(block_item, S):
#             # print('S')
#             resolved_statement = resolve_statement(block_item.statement, identifier_map)
#             # print('S end')
#             # print(resolved_statement)
#             resolved_body.append(S(statement=resolved_statement))
#         elif isinstance(block_item, Compound):
#             # Handle nested blocks by creating a new scope
#             new_identifier_map = copy_identifier_map(identifier_map)
#             resolved_compound = Compound(block=resolve_block_items(block_items=block_item.block, identifier_map=new_identifier_map))
#             resolved_body.append(resolved_compound)
#         else:
#             raise SyntaxError(f"Unknown block item type: {type(block_item)}")
#     return resolved_body

def resolve_block_items(block_items: List[BlockItem], identifier_map: dict) -> List[BlockItem]:
    resolved_body = []
    for block_item in block_items:
        if isinstance(block_item, D):
            if isinstance(block_item.declaration, VarDecl):
                print('here')
                resolved_declaration = resolve_declaration(block_item.declaration, identifier_map)
            elif isinstance(block_item.declaration, FunDecl):
                resolved_declaration = resolve_declaration(block_item.declaration, identifier_map)
            resolved_body.append(D(declaration=resolved_declaration))
        elif isinstance(block_item, S):
            resolved_statement = resolve_statement(block_item.statement, identifier_map)
            resolved_body.append(S(statement=resolved_statement))
        elif isinstance(block_item, Compound):
            new_identifier_map = copy_identifier_map(identifier_map)
            resolved_compound = Compound(block=resolve_block_items(block_items=block_item.block, identifier_map=new_identifier_map))
            resolved_body.append(resolved_compound)
        else:
            raise SyntaxError(f"Unknown block item type: {type(block_item)}")
    return resolved_body

def copy_identifier_map(identifier_map: Dict[str, Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:
    """
    Creates a copy of the variable map with 'from_current_scope' set to False for every entry.

    Args:
        identifier_map (Dict[str, Dict[str, Any]]): The original variable map.

    Returns:
        Dict[str, Dict[str, Any]]: A new variable map with updated 'from_current_scope' flags.
    """
    new_map = copy.deepcopy(identifier_map)
    for var_info in new_map.values():
        var_info['from_current_scope'] = False
    return new_map

def create_identifier_map(identifier_map: Dict[str, Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:
    # Create a deep copy to avoid mutating the original identifier_map
    identifier_map = copy.deepcopy(identifier_map)
    
    old_key = 'from_current_scope'       # Corrected spelling
    new_key = 'from_current_scope'
    
    # Check if the old key exists in the identifier_map
    if old_key in identifier_map:
        # Assign the value to the new key
        identifier_map[new_key] = identifier_map.pop(old_key)
        print(f"Renamed '{old_key}' to '{new_key}'.")
    else:
        print(f"Key '{old_key}' does not exist in the identifier_map.")
    
    return identifier_map

def resolve_statement(statement, identifier_map: dict) -> Any:
    # print('stmt')
    # print(statement)
    """
    Resolves a single statement by mapping variable identifiers to their unique names.

    Args:
        statement: The statement to resolve.
        identifier_map (dict): The current variable mapping.

    Returns:
        The resolved statement.

    Raises:
        SyntaxError: If an invalid statement type is encountered.
    """
    if isinstance(statement, Return):
        # print(statement)
        resolved_exp = resolve_exp(statement.exp, identifier_map)
        # print(resolved_exp)
        return Return(exp=resolved_exp)
    elif isinstance(statement,For):
        new_identifier_map = copy_identifier_map(identifier_map)
        init = resolve_for_init(statement.init,new_identifier_map)
        condition = resolve_optional_exp(statement.condition,new_identifier_map)
        post = resolve_optional_exp(statement.post,new_identifier_map)
        body = resolve_statement(statement.body,new_identifier_map)
        labeled_statement=label_statement(For(init,condition,post,body))
        return For(init,condition,post,body)
    elif isinstance(statement, Expression):
        resolved_exp = resolve_exp(statement.exp, identifier_map)
        return Expression(exp=resolved_exp)
    elif isinstance(statement, Compound):
        # Handle nested blocks by creating a new scope
        new_identifier_map = copy_identifier_map(identifier_map)
        resolved_block = resolve_block_items(block_items=statement.block, identifier_map=new_identifier_map)
        return Compound(block=resolved_block)
    elif isinstance(statement,While):
        resolved_condition = resolve_exp(statement._condition,identifier_map)
        resolved_body = resolve_statement(statement.body,identifier_map)
        labeled_statement=label_statement(While(_condition=resolved_condition,body=resolved_body))
        return labeled_statement
    elif isinstance(statement,DoWhile):
        resolved_condition = resolve_exp(statement._condition,identifier_map)
        resolved_body = resolve_statement(statement.body,identifier_map)
        labeled_statement=label_statement(DoWhile(body=resolved_body,_condition=resolved_condition))
        return labeled_statement
    elif isinstance(statement,Break):
        return Break()
    elif isinstance(statement,Continue):
        return Continue()
    elif isinstance(statement, If):
        resolved_exp = resolve_exp(statement.exp, identifier_map)
        resolved_then = resolve_statement(statement.then, identifier_map)
        if statement._else is not None:
            resolved_else = resolve_statement(statement._else, identifier_map)
            return If(exp=resolved_exp, then=resolved_then, _else=resolved_else)
        else:
            return If(exp=resolved_exp, then=resolved_then)
    elif isinstance(statement, Null):
        return Null()
    else:
        raise SyntaxError(f"Invalid statement type: {type(statement)}")

def annotate(statement: Statement, label: int) -> Statement:
    """
    Annotates a given statement with the provided label.
    """
    statement.label = label
    return statement

def resolve_block(block_list,identifier_map):

       
    return (resolve_block_items(block_items=block_list,identifier_map=identifier_map))

def resolve_param(param:Parameter,identifier_map):
    print('resolve param')
    """
    Resolves a variable declaration by ensuring no duplicate declarations
    in the current block and mapping the variable to a unique name.

    Args:
        declaration (Declaration): The variable declaration with a name and optional initialization.
        identifier_map (dict): A mapping of variable names to their unique names and block metadata.

    Returns:
        Declaration: The resolved declaration with a unique name and resolved initialization.

    Raises:
        TypeError: If the declaration name is not an Identifier.
        ValueError: If the variable is already declared in the current block.
    """
    # print('inside resolve param',param.name)
    if not isinstance(param.name, Identifier):
        raise TypeError(f"Declaration name must be an Identifier, got {type(param.name)}")

    original_name = param.name.name
    # Check for duplicate declarations in the same block
    if original_name in identifier_map and identifier_map[original_name]['from_current_scope']:
        raise ValueError(f"Duplicate variable declaration: '{original_name}'")

    # Generate a unique name for the variable
    unique_name = make_temporary()

    # Update the variable map with the new unique name and metadata
    identifier_map[original_name] = {'unique_name': unique_name, 'from_current_scope': True,'has_linkage':False}
    # print('resolve param end')
    # Resolve the initialization expression if present
    return Parameter(name=Identifier(unique_name),_type=param._type)

def label_statement(statement: Statement, current_label: Optional[Identifier] = None) -> Statement:
    """
    Traverses and annotates the AST with loop labels.

    Args:
        statement (Statement): The AST node to process.
        current_label (Optional[Identifier]): The current loop label, if within a loop.

    Returns:
        Statement: The annotated AST node.
    """
    # Handle lists of statements
    if isinstance(statement, list):
        for stmt in statement:
            label_statement(stmt, current_label)
        return statement

    # Handle specific statement types
    if isinstance(statement, Break):
        if current_label is None:
            raise ValueError("Error: 'break' statement outside of loop")
        statement.label = current_label

    elif isinstance(statement, Continue):
        if current_label is None:
            raise ValueError("Error: 'continue' statement outside of loop")
        statement.label = current_label

    elif isinstance(statement, While):
        # Generate a new label for this While loop
        new_label = get_label()
        annotate(statement, new_label)
        label_statement(statement.body, new_label)

    elif isinstance(statement, For):
        # Generate a new label for this For loop
        new_label = get_label()
        annotate(statement, new_label)
        if statement.body:
            label_statement(statement.body, new_label)

    elif isinstance(statement, DoWhile):
        # Generate a new label for this DoWhile loop
        new_label = get_label()
        annotate(statement, new_label)
        label_statement(statement.body, new_label)

    elif isinstance(statement, Compound):
        # Traverse each block item within the compound statement
        for block_item in statement.block:
            label_statement(block_item, current_label)

    elif isinstance(statement, S):
        print(statement)
        # Traverse the wrapped statement
        label_statement(statement.statement, current_label)

    elif isinstance(statement, D):
        # Handle declarations and their initializations
        # print('error here')
        if statement.declaration.init:
            label_statement(statement.declaration.init, current_label)

    elif isinstance(statement, Conditional):
        # Traverse the conditional branches (exp2 and exp3)
        label_statement(statement.exp2, current_label)
        label_statement(statement.exp3, current_label)
    elif isinstance(statement,If):
        label_statement(statement._else,current_label)
        label_statement(statement.then,current_label)
    elif isinstance(statement, (Return,Var,Constant)):
        # No labeling needed for return statements
        pass

    elif isinstance(statement, (Expression,Assignment,Binary,Unary)):
        # No labeling needed for expressions
        pass
    
    elif isinstance(statement, Null):
        # No labeling needed for null statements
        pass

    else:
        # Handle other statement types or raise an error
        raise TypeError(f"Unsupported statement type: {type(statement)}")

    return statement

def resolve_for_init(stmt,identifier_map):
    if isinstance(stmt,InitDecl):
        print(type(stmt.declaration))
        return InitDecl(D(resolve_declaration(stmt.declaration,identifier_map)))
    elif isinstance(stmt,InitExp):
        return InitExp(Expression(resolve_statement(stmt.exp,identifier_map)))
    elif isinstance(stmt,Null):
        return stmt
    else:
        raise TypeError('invalid init condition',stmt)
    
def resolve_optional_exp(stmt,identifier_map):
    if stmt is not None:
        return resolve_exp(stmt,identifier_map)
    else:
        print('No statment')
        pass 
        
def label_program(program: Program):
    """
    Labels all loops in the program's AST.
    
    Args:
        program (Program): The AST of the entire program.
    
    Returns:
        Program: The labeled AST.
    """
    # print('here')
    label_statement(program.function_definition.body, None)
    return program    

# def resolve_function(function: Function, identifier_map: dict) -> Function:
#     """
#     Resolves all block items within a function.

#     Args:
#         function (Function): The function to resolve.
#         identifier_map (dict): The current variable mapping.

#     Returns:
#         Function: The resolved function with all variables uniquely named.
#     """
#     resolved_body = resolve_block_items(block_items=function.body, identifier_map=identifier_map)
#     return Function(name=function.name, body=resolved_body)




def resolve_function_declaration(decl:FunDecl,identifier_map):
    # print(decl.name.name)
    # print('resolve func decl')
    # print('Error not here')
    if decl.name.name in identifier_map:
        prev_entry = identifier_map[decl.name.name]
        if prev_entry['from_current_scope'] and not prev_entry['has_linkage']==True:
            raise SyntaxError('Duplicate declaration')
    identifier_map[decl.name.name]={'unique_name':decl.name.name,'from_current_scope':True,'has_linkage':True}
    # print('error not here')
    inner_map = copy_identifier_map(identifier_map)
    # print('heredfadas')
    # print(inner_map)
    new_param =[]
    # print(decl.params)
    for param in decl.params:
        # print(param)
        new_param.append(resolve_param(param,inner_map))
        # print('here')
    # print(decl.body)
    new_body = Null
    if  isinstance(decl.body,Block):
        # print(decl.body.block_items)
        # print('here')
        new_body=resolve_block(decl.body.block_items,inner_map)
        # print('here after')
        # print(new_body)
    return FunDecl(decl.name,new_param,new_body)
def variable_resolution_pass(program: Program) -> Program:
    """
    Performs the variable resolution pass on the entire program.

    Args:
        program (Program): The program to resolve.

    Returns:
        Program: The resolved program with all variables uniquely named.
    """
    identifier_map = {}
    func=[]
    for x in program.function_definition:
        # print(x)
        new_func=resolve_function_declaration(x,identifier_map)
        # print(new_func)
        func.append(new_func)
        
    # resolved_function = resolve_function(program.function_definition, identifier_map)
    # print('here')
    prog=Program(function_definition=func)
    return prog







# pseudoregister_replacer.py

from typing import Dict, Tuple, List
from assembly_ast import *
import sys
from instruction_fixer import round_up_to_multiple_of_16



def replace_pseudoregisters(assembly_program: AssemblyProgram) -> Tuple[AssemblyProgram, Dict[str, int]]:
    """
    Replaces all Pseudo operands in the Assembly AST with Stack operands for each function.
    Calculates and returns the stack allocation required for each function.

    Additionally, rewrites 'idiv', 'add', 'sub', and 'imul' instructions to adhere to assembly constraints
    (especially for 64-bit mode).

    NOTE: This version uses 8-byte slots for each pseudo register and inserts 'Cdq' before 'idiv'.
    """
    stack_allocations: Dict[str, int] = {}

    # Assume a single function for simplicity
    for assembly_func in assembly_program.function_definition:
        # print(assembly_func)

        # Maps pseudo register names to stack offsets
        pseudo_map: Dict[str, int] = {}

        # Initialize stack offset; start at -8(%rbp)
        # current_offset
        # List to hold the new set of instructions after replacement
        current_offset= -8
        
        new_instructions: List[Instruction] = []
        def replace_pseudo_with_stack(operand):
            """
            If the operand is a Pseudo, replace it with a Stack operand at the next available offset.
            """
            nonlocal current_offset
            
            if isinstance(operand, Pseudo):
                name = operand.identifier
                if name not in pseudo_map:
                    pseudo_map[name] = current_offset
                    current_offset -= 8  # Allocate 8 bytes for each pseudo register
                return Stack(pseudo_map[name])
            return operand
        params=assembly_func.instructions[0]
        new_params=[]
        # print('parameters',params)
        for param in params:
            if isinstance(param, Mov):  # Assuming parameters are identified by their names as strings
                param.dest=replace_pseudo_with_stack(param.dest)
                param.src=replace_pseudo_with_stack(param.src) 
                new_params.append(param)
            #     param=param.dest
            #     pseudo_map[param] = current_offset
            #     current_offset -= 8  # Allocate 8 bytes for each parameter
            # else:
            #     print(f"Unexpected parameter type: {type(param).__name__} in function '{assembly_func.name}'.", file=sys.stderr)
            #     sys.exit(1)
        # Iterate through each instruction in the function
        # new_instructions.extend(new_params)
        # print('new_params',new_params)
        new_instructions.extend(new_params)
        instrs=assembly_func.instructions[1:]
        for instr in instrs :

            if isinstance(instr, Mov):
                # Replace source and destination if they are Pseudo
                instr.src = replace_pseudo_with_stack(instr.src)
                instr.dest = replace_pseudo_with_stack(instr.dest)
                new_instructions.append(instr)
            
            elif isinstance(instr, Unary):
                # Replace the operand if it's a Pseudo
                instr.operand = replace_pseudo_with_stack(instr.operand)
                new_instructions.append(instr)
            
            elif isinstance(instr, Binary):
                # Replace src1 and src2 if they are Pseudo
                instr.src1 = replace_pseudo_with_stack(instr.src1)
                instr.src2 = replace_pseudo_with_stack(instr.src2)
                new_instructions.append(instr)
            
            elif isinstance(instr, Idiv):
                # Replace the operand if it's a Pseudo
                instr.operand = replace_pseudo_with_stack(instr.operand)
                new_instructions.append(instr)
            
            elif isinstance(instr, Cmp):
                # Replace the operand if it's a Pseudo
                instr.operand1 = replace_pseudo_with_stack(instr.operand1)
                instr.operand2 = replace_pseudo_with_stack(instr.operand2)
                new_instructions.append(instr)
            elif isinstance(instr, SetCC):
                # Replace the operand if it's a Pseudo
                # print('STECC',instr)
                instr.operand = replace_pseudo_with_stack(instr.operand)
                new_instructions.append(instr)
                # instr.operand2 = replace_pseudo_with_stack(instr.operand2)
            elif isinstance(instr,Push):
                instr.operand=replace_pseudo_with_stack(instr.operand)
                new_instructions.append(instr)
            elif isinstance(instr, (AllocateStack, Ret, Cdq,JmpCC,Jmp,Label,Call,DeallocateStack)):
                # These instructions do not contain Pseudo operands; add them directly
                new_instructions.append(instr)
            
            else:
                # Unsupported instruction type encountered
                print(f"Unsupported instruction type: {type(instr).__name__} in function '{assembly_func.name}'.", file=sys.stderr)
                sys.exit(1)

        # Update the function's instructions with the new set of instructions
        # assembly_func.instructions=new_params
        assembly_func.instructions=new_instructions
        
        # Calculate total stack allocation required for all replaced pseudoregisters
        # Since current_offset started at -8 and decremented by 8 for each Pseudo
        # The total allocation is the absolute value of (current_offset + 8)
        # total_stack_allocation = abs(current_offset + 8)
        total_stack_allocation = abs(current_offset + 8)
        total_stack_allocation = round_up_to_multiple_of_16(total_stack_allocation)

        stack_allocations[assembly_func.name] = total_stack_allocation

    return assembly_program, stack_allocations
